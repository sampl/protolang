-- INITIALIZE DATABASE
-- This should only be run once, when the database is first created
-- See docs/readme.md for full directions

-------------------------------------------------
-----------------     TABLES    -----------------
-------------------------------------------------

-- TODO
-- - new supabase project
-- - try to run this bad boy and see what happens

-----------------   Users   -----------------

create table users (
  id          uuid references auth.users(id) not null primary key,

  preferences jsonb,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

create table profiles (
  id          uuid references auth.users(id) not null primary key,

  username    text unique,
  full_name   text,
  bio         text,
  avatar_url  text,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

----------------- Languages -----------------

create table languages (
  id          text primary key,

  name_en     text unique not null,
  flag        text unique not null,
  is_live     boolean default false not null,
  is_beta     boolean,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

create table user_languages (
  id                  bigint generated by default as identity primary key,

  language            text not null references languages(id),
  preferences         jsonb,

  created_at          timestamptz default now() not null,
  updated_at          timestamptz default now() not null,
  created_by          uuid not null references auth.users(id)
);

-----------------   Words   -----------------

create table words (
  id              bigint generated by default as identity primary key, -- or word string?

  language        text not null references languages(id),
  name            text not null,
  -- translation_en  text not null,
  -- literal_en      text,
  -- context_en      text,
  wiktionary_data jsonb not null,

  created_at      timestamptz default now() not null,
  updated_at      timestamptz default now() not null,
  created_by      uuid not null references auth.users(id)
);

-----------------  Attempts -----------------

create type attempt_type as enum ('chat_conversation', 'flashcard_guess'); -- TODO rename attempts to flashcard guesses? since we're not really using them for chat or anything else, and maybe we won't even
create table attempts (
  id          bigint generated by default as identity primary key,

  word        bigint not null references words(id),
  guess       text,
  correct     boolean not null,
  type        attempt_type not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-----------------   Chats   -----------------

create table chat_conversations (
  id          bigint generated by default as identity primary key,

  language    text not null references languages(id),

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

create type sender_type as enum ('user', 'robot');
create table chat_messages (
  id                bigint generated by default as identity primary key,

  chat_conversation bigint not null references chat_conversations(id),
  content           text not null,
  sender_type       sender_type not null,
  sender_user       uuid references auth.users(id),

  created_at        timestamptz default now() not null,
  updated_at        timestamptz default now() not null,
  created_by        uuid not null references auth.users(id)
);

-----------------  Lessons  -----------------

create table lessons (
  id          bigint generated by default as identity primary key,

  title_en    text not null,
  content_en  text,
  language    text not null references languages(id),
  sort_order  bigint,
  words       jsonb,
  slug        text unique,
  is_public   boolean not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-----------------   Lists   -----------------

create table lists (
  id          bigint generated by default as identity primary key,

  name        text not null,
  is_public   boolean not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

create table list_items (
  id          bigint generated by default as identity primary key,

  list        bigint not null references lists(id),
  word        bigint not null references words(id),
  sort_order  bigint,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-----------------   Media   -----------------

create type media_type as enum ('video', 'book', 'article', 'podcast', 'film', 'other'); -- TODO - match to onboarding
create table media (
  id          bigint generated by default as identity primary key,

  name        text,
  url         text not null,
  type        media_type not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

----------------- Mnemonics -----------------

create table mnemonics (
  id          bigint generated by default as identity primary key,

  word        bigint not null references words(id),
  content_en  text not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

create type mnemonic_vote_type as enum ('upvote'); -- TODO
create table mnemonic_votes (
  id          bigint generated by default as identity primary key,

  mnemonic    bigint not null references mnemonics(id),
  type        mnemonic_vote_type default 'upvote' not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

----------------- Resources -----------------

create table resources (
  id            bigint generated by default as identity primary key,

  language      text not null references languages(id),
  url           text unique not null,
  _scraped_info jsonb,

  created_at    timestamptz default now() not null,
  updated_at    timestamptz default now() not null,
  created_by    uuid not null references auth.users(id)
);

create table resource_ratings (
  id          bigint generated by default as identity primary key,

  resource    bigint not null references resources(id),
  stars       bigint,
  content     text,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-----------------   Admin    -----------------

create table error_reports (
  id          bigint generated by default as identity primary key,

  word        bigint not null references words(id),
  comment     text,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);


-------------------------------------------------
--------------  ROW-LEVEL-SECURITY  -------------
-------------------------------------------------

-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security for more details.

-----------------   Users   -----------------

alter table users enable row level security;
create policy "Users can view their own user"   on users for select using (auth.uid() = id);
create policy "Users can add their own user"    on users for insert to authenticated with check (auth.uid() = id);
create policy "Users can update their own user" on users for update using (auth.uid() = id);
create policy "Nobody can delete a user"        on users for delete using (false);

alter table profiles enable row level security;
create policy "Anyone can view a profile"            on profiles for select using (true);
create policy "Users can add their own profile"      on profiles for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own profiles"  on profiles for update using (auth.uid() = created_by);
create policy "Nobody can delete a profile"          on profiles for delete using (false);

----------------- Languages -----------------

-- do we not need RLS here?
alter table languages enable row level security;
create policy "Anyone can view a language"    on languages for select using (true);
create policy "Nobody can add a language"     on languages for insert with check (false);
create policy "Nobody can update a language"  on languages for update using (false);
create policy "Nobody can delete a language"  on languages for delete using (false);

alter table user_languages enable row level security;
create policy "Users can view their own user languages" on user_languages for select using (auth.uid() = created_by);
CREATE POLICY "Users can add their own user languages"  on user_languages for insert to authenticated with check ((auth.uid() = created_by));
create policy "Users can update their user languages"   on user_languages for update using (auth.uid() = created_by);
create policy "Nobody can delete a user language"       on user_languages for delete using (false);

-----------------   Words   -----------------

-- do we not need RLS here?
alter table words enable row level security;
create policy "Anyone can view a word"    on words for select using (true);
create policy "Nobody can add a word"     on words for insert with check (false);
create policy "Nobody can update a word"  on words for update using (false);
create policy "Nobody can delete a word"  on words for delete using (false);

-----------------  Attempts -----------------

alter table attempts enable row level security;
create policy "Users can view their own attempts"  on attempts for select using (auth.uid() = created_by);
create policy "Users can add an attempt"           on attempts for insert to authenticated with check (auth.uid() = created_by);
create policy "Nobody can update an attempt"       on attempts for update using (false);
create policy "Nobody can delete an attempt"       on attempts for delete using (false);

-----------------   Chats   -----------------

alter table chat_conversations enable row level security;
create policy "Users can view their own chat conversations"  on chat_conversations for select using (auth.uid() = created_by);
create policy "Users can add a chat conversation"            on chat_conversations for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their chat conversations"    on chat_conversations for update using (auth.uid() = created_by);
create policy "Nobody can delete a chat conversation"        on chat_conversations for delete using (false);

-- issue if others can see bot responses to users messages?
alter table chat_messages enable row level security;
create policy "Users can view their own chat messages"  on chat_messages for select using (auth.uid() = created_by);
create policy "Users can add a chat message"            on chat_messages for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their chat messages"    on chat_messages for update using (auth.uid() = created_by);
create policy "Nobody can delete a chat message"        on chat_messages for delete using (false);

-----------------  Lessons  -----------------

-- do we not need RLS here?
alter table lessons enable row level security;
create policy "Anyone can view a lesson if it's public" on lessons for select using (auth.uid() = created_by or is_public = true);
create policy "Users can add a lesson"                  on lessons for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own lessons"      on lessons for update using (auth.uid() = created_by);
create policy "Users can delete their own lessons"      on lessons for delete using (auth.uid() = created_by);

-----------------   Lists   -----------------

alter table lists enable row level security;
create policy "Anyone can view a list if it's public" on lists for select using (auth.uid() = created_by or is_public = true);
create policy "Users can add a list"                  on lists for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own lists"      on lists for update using (auth.uid() = created_by);
create policy "Users can delete their own lists"      on lists for delete using (auth.uid() = created_by);

alter table list_items enable row level security;
create policy "Anyone can view a list item if the list it's in is public" on list_items for select using (
  auth.uid() = created_by or 
  EXISTS(
    SELECT 1 FROM lists AS list
      WHERE id = list.id
      AND is_public = true
  )
);
create policy "Users can add a list item if it's their list"      on list_items for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own list items"             on list_items for update using (auth.uid() = created_by);
create policy "Users can delete their own list items"             on list_items for delete using (auth.uid() = created_by);

-----------------   Media   -----------------

alter table media enable row level security;
create policy "Anyone can view a media item"            on media for select using (true);
create policy "Users can add a media item"              on media for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own media idems"  on media for update using (auth.uid() = created_by);
create policy "Nobody can delete a media item"          on media for delete using (false);

----------------- Mnemonics -----------------

alter table mnemonics enable row level security;
create policy "Anyone can view a mnemonic"            on mnemonics for select using (true);
create policy "Users can add a mnemonic"              on mnemonics for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own mnemonics"  on mnemonics for update using (auth.uid() = created_by);
create policy "Nobody can delete a mnemonic"          on mnemonics for delete using (false);

alter table mnemonic_votes enable row level security;
create policy "Anyone can view a mnemonic vote"             on mnemonic_votes for select using (true);
create policy "Users can add a mnemonic vote"               on mnemonics for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own mnemonic votes"   on mnemonic_votes for update using (auth.uid() = created_by);
create policy "Users can delete their own mnemonic vote"    on mnemonic_votes for delete using (auth.uid() = created_by);

----------------- Resources -----------------

alter table resources enable row level security;
create policy "Anyone can view a resource"            on resources for select using (true);
create policy "Users can add a resource"              on resources for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own resources"  on resources for update using (auth.uid() = created_by);
create policy "Nobody can delete a resource"          on resources for delete using (false);

alter table resource_ratings enable row level security;
create policy "Anyone can view a resource rating"            on resource_ratings for select using (true);
create policy "Users can add a resource rating"              on resource_ratings for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own resource ratings"  on resource_ratings for update using (auth.uid() = created_by);
create policy "Users can delete their own resource rating"   on resource_ratings for delete using (auth.uid() = created_by);

-----------------   Admin    -----------------

alter table error_reports enable row level security;
create policy "Anyone can view error reports"              on error_reports for select using (true);
create policy "Users can add an error report"              on error_reports for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own error reports"   on error_reports for update using (auth.uid() = created_by);
create policy "Nobody can delete an error report"          on error_reports for delete using (false);


-------------------------------------------------
-----------------    TRIGGERS   -----------------
-------------------------------------------------

create extension if not exists moddatetime schema extensions;

-- keep updated_at timestamps up to date on all tables
-- https://github.com/supabase/supabase/issues/379#issuecomment-755289862
create trigger keep_users_updated               before update on users              for each row execute procedure moddatetime (updated_at);
create trigger keep_profiles_updated            before update on profiles           for each row execute procedure moddatetime (updated_at);
create trigger keep_languages_updated           before update on languages          for each row execute procedure moddatetime (updated_at);
create trigger keep_user_languages_updated      before update on user_languages     for each row execute procedure moddatetime (updated_at);
create trigger keep_words_updated               before update on words              for each row execute procedure moddatetime (updated_at);
create trigger keep_attempts_updated            before update on attempts           for each row execute procedure moddatetime (updated_at);
create trigger keep_chat_conversations_updated  before update on chat_conversations for each row execute procedure moddatetime (updated_at);
create trigger keep_chat_messages_updated       before update on chat_messages      for each row execute procedure moddatetime (updated_at);
create trigger keep_lessons_updated             before update on lessons            for each row execute procedure moddatetime (updated_at);
create trigger keep_lists_updated               before update on lists              for each row execute procedure moddatetime (updated_at);
create trigger keep_list_items_updated          before update on list_items         for each row execute procedure moddatetime (updated_at);
create trigger keep_media_updated               before update on media              for each row execute procedure moddatetime (updated_at);
create trigger keep_mnemonics_updated           before update on mnemonics          for each row execute procedure moddatetime (updated_at);
create trigger keep_mnemonic_votes_updated      before update on mnemonic_votes     for each row execute procedure moddatetime (updated_at);
create trigger keep_resources_updated           before update on resources          for each row execute procedure moddatetime (updated_at);
create trigger keep_resource_ratings_updated    before update on resource_ratings   for each row execute procedure moddatetime (updated_at);
create trigger keep_error_reports_updated       before update on error_reports      for each row execute procedure moddatetime (updated_at);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.
-- TODO - verify
create function handle_new_user()
returns trigger as $$
begin
  insert into profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure handle_new_user();


-------------------------------------------------
-----------------     VIEWS     -----------------
-------------------------------------------------

-- https://supabase.com/blog/2020/11/18/postgresql-views
create or replace view heatmap_days as
  select    date(created_at), created_by, count(*)
  from      attempts
  where     created_at > current_date - interval '1 year'
  group by  date(created_at), created_by;

create or replace view user_scores as
  select    created_by, count(distinct word)
  from      attempts
  where     correct = true
  group by  created_by;

-- https://stackoverflow.com/questions/27253333/how-to-calculate-ratio-using-sql-query
-- https://stackoverflow.com/questions/28736227/cast-syntax-to-convert-a-sum-to-float
create or replace view user_word_scores as
  select
    created_by,
    word,
    count(*),
    sum(case when correct = true then 1 else 0 end) as num_correct,
    sum(case when correct = true then 1 else 0 end)::float/count(*)::float as percent_correct
  from attempts
  group by created_by, word;


-------------------------------------------------
-----------------     SEED      -----------------
-------------------------------------------------

-- TODO - add more languages
-- https://en.wikipedia.org/wiki/List_of_languages_by_total_number_of_speakers

relation "languages" does not exist
insert into 
  public.languages (id, flag, name_en)
values
  ('fr', '🇫🇷', 'French'),
  ('ja', '🇯🇵', 'Japanese'),
  ('de', '🇩🇪', 'German'),
  ('zh', '🇨🇳', 'Chinese'),
  ('hi', '🇮🇳', 'Hindi'),
  ('eo', '🌍', 'Esperanto'),
  ('la', '🏛', 'Latin'),
  ('pt', '🇵🇹', 'Portuguese'),
  ('ru', '🇷🇺', 'Russian'),
  ('ar', '🇸🇦', 'Arabic'),
  ('bn', '🇧🇩', 'Bengali'),
  ('id', '🇮🇩', 'Indonesian'),
  ('ko', '🇰🇷', 'Korean'),
  ('es', '🇪🇸', 'Spanish'),
  ('it', '🇮🇹', 'Italian'),
  ('tp', '🏳', 'Toki Pona'),
  ('nv', '🏳️‍🌈', 'Navajo');

-- TODO - make this a real seed or delete
-- it	cheers	salute	phrase	health	toast for drinking
-- it	yes	si	lexeme
-- it	no	no	lexeme
-- it	I don't know	non lo so	phrase
-- it	hi (or bye)	ciao	lexeme	\N	casual greeting
-- it	welcome	benvenuta/o	lexeme
-- it	nice to meet you	piacere	phrase	pleasure
-- it	excuse me	mi scusi	phrase
-- it	sorry	spiacente	lexeme
-- it	maybe	può essere	lexeme	can be
-- it	please	per favore	phrase	for favor
-- it	thank you	grazie	phrase
-- it	you're welcome	prego	word
