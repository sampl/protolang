-------------------------------------------------
-----------------     TABLES    -----------------
-------------------------------------------------

-----------------   Users   -----------------

create table users (
  id                uuid references auth.users(id) not null primary key,

  preferences       jsonb,
  onboarding_flags  jsonb,

  created_at        timestamptz default now() not null,
  updated_at        timestamptz default now() not null,
  created_by        uuid not null references auth.users(id)
);

create table profiles (
  id            uuid references auth.users(id) not null primary key,

  username      text unique,
  full_name     text,
  bio           text,
  avatar_url    text,

  created_at    timestamptz default now() not null,
  updated_at    timestamptz default now() not null,
  created_by    uuid not null references auth.users(id)
);

create table profile_follows (
  id                bigint generated by default as identity primary key,

  follows_profile   uuid references profiles(id) not null,

  created_at        timestamptz default now() not null,
  updated_at        timestamptz default now() not null,
  created_by        uuid not null references auth.users(id)
);

----------------- Languages -----------------

create table languages (
  id          text primary key,

  name_en     text unique not null,
  flag        text unique not null,
  is_beta     boolean default false not null,
  is_live     boolean default false not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null
);

create table user_languages (
  id                  bigint generated by default as identity primary key,

  language            text not null references languages(id),
  preferences         jsonb,

  created_at          timestamptz default now() not null,
  updated_at          timestamptz default now() not null,
  created_by          uuid not null references auth.users(id)
);

-----------------   Phrases   -----------------

create table phrases (
  id              bigint generated by default as identity primary key,

  language        text not null references languages(id),
  name            text not null,
  translation_en  text not null,
  alternates      jsonb,

  created_at      timestamptz default now() not null,
  updated_at      timestamptz default now() not null,
  created_by      uuid not null references auth.users(id)
);

create table phrase_issues (
  id            bigint generated by default as identity primary key,

  language      text not null references languages(id),
  phrase        bigint not null references phrases(id),
  comment       text,
  is_resolved   boolean default false not null,

  created_at    timestamptz default now() not null,
  updated_at    timestamptz default now() not null,
  created_by    uuid not null references auth.users(id)
);

-----------------  Practice -----------------

create table practice_attempts (
  id          bigint generated by default as identity primary key,

  language    text not null references languages(id),
  phrase      bigint not null references phrases(id),
  guess       text,
  is_correct  boolean not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-----------------   Chats   -----------------

create table chat_conversations (
  id          bigint generated by default as identity primary key,

  language    text not null references languages(id),

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

create type sender_type as enum ('user', 'robot');
create table chat_messages (
  id                bigint generated by default as identity primary key,

  chat_conversation bigint not null references chat_conversations(id),
  content           text not null,
  sender_type       sender_type not null,
  sender_user       uuid references auth.users(id),

  created_at        timestamptz default now() not null,
  updated_at        timestamptz default now() not null,
  created_by        uuid not null references auth.users(id)
);

-----------------  Lessons  -----------------

create table lessons (
  id          bigint generated by default as identity primary key,

  language    text not null references languages(id),
  title_en    text not null,
  content_en  text,
  sort_order  bigint,
  words       jsonb,
  slug        text unique,
  is_public   boolean default false not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-----------------   Lists   -----------------

-- unclear if lists should be for words or phrases
-- if they're for words, I guess they should just reference the words table by text (no FK)

-- create table lists (
--   id          bigint generated by default as identity primary key,

--   language    text not null references languages(id),
--   name        text not null,
--   is_public   boolean not null,

--   created_at  timestamptz default now() not null,
--   updated_at  timestamptz default now() not null,
--   created_by  uuid not null references auth.users(id)
-- );

-- create table list_items (
--   id          bigint generated by default as identity primary key,

--   list        bigint not null references lists(id),
--   word        bigint not null references words(id), -- not a thing anymore
--   sort_order  bigint,

--   created_at  timestamptz default now() not null,
--   updated_at  timestamptz default now() not null,
--   created_by  uuid not null references auth.users(id)
-- );

-----------------   Media   -----------------

create type media_type as enum ('book', 'article', 'podcast', 'video', 'tv_show', 'film', 'other');
create table media (
  id          bigint generated by default as identity primary key,

  language    text not null references languages(id),
  name        text,
  url         text not null,
  type        media_type not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-- TODO - stars on media ratings? or just use likes for everything? like and double-like?
create table media_ratings (
  id          bigint generated by default as identity primary key,

  media       bigint not null references media(id),
  stars       smallint,
  content     text,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

----------------- Mnemonics -----------------

create table mnemonics (
  id                bigint generated by default as identity primary key,

  language          text not null references languages(id),
  target_phrase     text not null,
  remember_method   text not null,

  created_at        timestamptz default now() not null,
  updated_at        timestamptz default now() not null,
  created_by        uuid not null references auth.users(id)
);

create type mnemonic_vote_type as enum ('upvote'); -- TODO
create table mnemonic_votes (
  id          bigint generated by default as identity primary key,

  mnemonic    bigint not null references mnemonics(id),
  type        mnemonic_vote_type default 'upvote' not null,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

----------------- Resources -----------------

create table resources (
  id            bigint generated by default as identity primary key,

  language      text not null references languages(id),
  url           text unique not null,
  _scraped_info jsonb,

  created_at    timestamptz default now() not null,
  updated_at    timestamptz default now() not null,
  created_by    uuid not null references auth.users(id)
);

create table resource_ratings (
  id          bigint generated by default as identity primary key,

  resource    bigint not null references resources(id),
  stars       smallint,
  content     text,

  created_at  timestamptz default now() not null,
  updated_at  timestamptz default now() not null,
  created_by  uuid not null references auth.users(id)
);

-----------------   Migrations    -----------------

create table migrations (
  id          bigint generated by default as identity primary key,
  created_at  timestamptz default now() not null
);


-------------------------------------------------
--------------  ROW-LEVEL-SECURITY  -------------
-------------------------------------------------

-- https://supabase.com/docs/guides/auth/row-level-security

-----------------   Users   -----------------

alter table users enable row level security;
create policy "Users can view their own user"   on users for select using (auth.uid() = id);
create policy "Users can add their own user"    on users for insert to authenticated with check (auth.uid() = id);
create policy "Users can update their own user" on users for update using (auth.uid() = id);
create policy "Nobody can delete a user"        on users for delete using (false);

alter table profiles enable row level security;
create policy "Anyone can view a profile"            on profiles for select using (true);
create policy "Users can add their own profile"      on profiles for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own profile"   on profiles for update using (auth.uid() = created_by);
create policy "Nobody can delete a profile"          on profiles for delete using (false);

alter table profile_follows enable row level security;
create policy "Anyone can view a profile follow"            on profile_follows for select using (true);
create policy "Users can add their own profile follow"      on profile_follows for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own profile follow"   on profile_follows for update using (auth.uid() = created_by);
create policy "Users can delete their own profile follow"   on profile_follows for delete using (auth.uid() = created_by);

----------------- Languages -----------------

alter table languages enable row level security;
create policy "Anyone can view a language"    on languages for select using (true);
create policy "Nobody can add a language"     on languages for insert with check (false);
create policy "Nobody can update a language"  on languages for update using (false);
create policy "Nobody can delete a language"  on languages for delete using (false);

alter table user_languages enable row level security;
create policy "Users can view their own user language"  on user_languages for select using (auth.uid() = created_by);
create policy "Users can add their own user language"   on user_languages for insert to authenticated with check ((auth.uid() = created_by));
create policy "Users can update their user language"    on user_languages for update using (auth.uid() = created_by);
create policy "Nobody can delete a user language"       on user_languages for delete using (false);

-----------------   Phrases   -----------------

alter table phrases enable row level security;
create policy "Anyone can view a phrase"           on phrases for select using (true);
create policy "Users can add a phrase"             on phrases for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own phrase"  on phrases for update using (auth.uid() = created_by);
create policy "Nobody can delete a phrase"         on phrases for delete using (false);

alter table phrase_issues enable row level security;
create policy "Anyone can view a phrase issue"           on phrase_issues for select using (true);
create policy "Users can add a phrase issue"             on phrase_issues for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own phrase issue"  on phrase_issues for update using (auth.uid() = created_by);
create policy "Nobody can delete a phrase issue"         on phrase_issues for delete using (false);

-----------------  Practice attempts -----------------

alter table practice_attempts enable row level security;
create policy "Users can view their own practice attempt"   on practice_attempts for select using (auth.uid() = created_by);
create policy "Users can add an practice attempt"           on practice_attempts for insert to authenticated with check (auth.uid() = created_by);
create policy "Nobody can update an practice attempt"       on practice_attempts for update using (false);
create policy "Nobody can delete an practice attempt"       on practice_attempts for delete using (false);

-----------------   Chats   -----------------

alter table chat_conversations enable row level security;
create policy "Users can view their own chat conversation"   on chat_conversations for select using (auth.uid() = created_by);
create policy "Users can add a chat conversation"            on chat_conversations for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their chat conversation"     on chat_conversations for update using (auth.uid() = created_by);
create policy "Nobody can delete a chat conversation"        on chat_conversations for delete using (false);

-- issue if others can see bot responses to users messages?
alter table chat_messages enable row level security;
create policy "Users can view their own chat message"   on chat_messages for select using (auth.uid() = created_by);
create policy "Users can add a chat message"            on chat_messages for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their chat message"     on chat_messages for update using (auth.uid() = created_by);
create policy "Nobody can delete a chat message"        on chat_messages for delete using (false);

-----------------  Lessons  -----------------

-- do we not need RLS here?
alter table lessons enable row level security;
create policy "Anyone can view a lesson if it's public" on lessons for select using (auth.uid() = created_by or is_public = true);
create policy "Users can add a lesson"                  on lessons for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own lesson"       on lessons for update using (auth.uid() = created_by);
create policy "Users can delete their own lesson"       on lessons for delete using (auth.uid() = created_by);

-----------------   Lists   -----------------

-- alter table lists enable row level security;
-- create policy "Anyone can view a list if it's public" on lists for select using (auth.uid() = created_by or is_public = true);
-- create policy "Users can add a list"                  on lists for insert to authenticated with check (auth.uid() = created_by);
-- create policy "Users can update their own list"       on lists for update using (auth.uid() = created_by);
-- create policy "Users can delete their own list"       on lists for delete using (auth.uid() = created_by);

-- alter table list_items enable row level security;
-- create policy "Anyone can view a list item if the list it's in is public" on list_items for select using (
--   auth.uid() = created_by or 
--   EXISTS(
--     SELECT 1 FROM lists AS list
--       WHERE id = list.id
--       AND is_public = true
--   )
-- );
-- create policy "Users can add a list item if it's their list"      on list_items for insert to authenticated with check (auth.uid() = created_by);
-- create policy "Users can update their own list item"              on list_items for update using (auth.uid() = created_by);
-- create policy "Users can delete their own list item"              on list_items for delete using (auth.uid() = created_by);

-----------------   Media   -----------------

alter table media enable row level security;
create policy "Anyone can view a media item"            on media for select using (true);
create policy "Users can add a media item"              on media for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own media item"   on media for update using (auth.uid() = created_by);
create policy "Nobody can delete a media item"          on media for delete using (false);

alter table media_ratings enable row level security;
create policy "Anyone can view a media rating"            on media_ratings for select using (true);
create policy "Users can add a media rating"              on media_ratings for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own media rating"   on media_ratings for update using (auth.uid() = created_by);
create policy "Users can delete their own media rating"   on media_ratings for delete using (auth.uid() = created_by);

----------------- Mnemonics -----------------

alter table mnemonics enable row level security;
create policy "Anyone can view a mnemonic"            on mnemonics for select using (true);
create policy "Users can add a mnemonic"              on mnemonics for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own mnemonic"   on mnemonics for update using (auth.uid() = created_by);
create policy "Nobody can delete a mnemonic"          on mnemonics for delete using (false);

alter table mnemonic_votes enable row level security;
create policy "Anyone can view a mnemonic vote"             on mnemonic_votes for select using (true);
create policy "Users can add a mnemonic vote"               on mnemonics for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own mnemonic vote"    on mnemonic_votes for update using (auth.uid() = created_by);
create policy "Users can delete their own mnemonic vote"    on mnemonic_votes for delete using (auth.uid() = created_by);

----------------- Resources -----------------

alter table resources enable row level security;
create policy "Anyone can view a resource"            on resources for select using (true);
create policy "Users can add a resource"              on resources for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own resource"   on resources for update using (auth.uid() = created_by);
create policy "Nobody can delete a resource"          on resources for delete using (false);

alter table resource_ratings enable row level security;
create policy "Anyone can view a resource rating"            on resource_ratings for select using (true);
create policy "Users can add a resource rating"              on resource_ratings for insert to authenticated with check (auth.uid() = created_by);
create policy "Users can update their own resource rating"   on resource_ratings for update using (auth.uid() = created_by);
create policy "Users can delete their own resource rating"   on resource_ratings for delete using (auth.uid() = created_by);

-----------------   Migrations    -----------------

-- may or may not need this, better to be explicit
alter table migrations enable row level security;
create policy "Nobody can view a migration"             on migrations for select using (false);
create policy "Nobody can add a migration"              on migrations for insert with check (false);
create policy "Nobody can update a migration"           on migrations for update using (false);
create policy "Nobody can delete a migration"           on migrations for delete using (false);


-------------------------------------------------
-----------------    TRIGGERS   -----------------
-------------------------------------------------

create extension if not exists moddatetime schema extensions;

-- keep updated_at timestamps up to date on all tables
-- https://github.com/supabase/supabase/issues/379#issuecomment-755289862
create trigger keep_users_updated               before update on users              for each row execute procedure moddatetime (updated_at);
create trigger keep_profiles_updated            before update on profiles           for each row execute procedure moddatetime (updated_at);
create trigger keep_profile_follows_updated     before update on profile_follows    for each row execute procedure moddatetime (updated_at);
create trigger keep_languages_updated           before update on languages          for each row execute procedure moddatetime (updated_at);
create trigger keep_user_languages_updated      before update on user_languages     for each row execute procedure moddatetime (updated_at);
create trigger keep_phrases_updated             before update on phrases            for each row execute procedure moddatetime (updated_at);
create trigger keep_phrase_issues_updated       before update on phrase_issues      for each row execute procedure moddatetime (updated_at);
create trigger keep_practice_attempts_updated   before update on practice_attempts  for each row execute procedure moddatetime (updated_at);
create trigger keep_chat_conversations_updated  before update on chat_conversations for each row execute procedure moddatetime (updated_at);
create trigger keep_chat_messages_updated       before update on chat_messages      for each row execute procedure moddatetime (updated_at);
create trigger keep_lessons_updated             before update on lessons            for each row execute procedure moddatetime (updated_at);
-- create trigger keep_lists_updated               before update on lists              for each row execute procedure moddatetime (updated_at);
-- create trigger keep_list_items_updated          before update on list_items         for each row execute procedure moddatetime (updated_at);
create trigger keep_media_updated               before update on media              for each row execute procedure moddatetime (updated_at);
create trigger keep_media_ratings_updated       before update on media_ratings      for each row execute procedure moddatetime (updated_at);
create trigger keep_mnemonics_updated           before update on mnemonics          for each row execute procedure moddatetime (updated_at);
create trigger keep_mnemonic_votes_updated      before update on mnemonic_votes     for each row execute procedure moddatetime (updated_at);
create trigger keep_resources_updated           before update on resources          for each row execute procedure moddatetime (updated_at);
create trigger keep_resource_ratings_updated    before update on resource_ratings   for each row execute procedure moddatetime (updated_at);

-- TODO - this is broken, doesn't hurt but doesn't work
-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.
create function handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url, created_by)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url',
    new.id
  );
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure handle_new_user();


-------------------------------------------------
-----------------     VIEWS     -----------------
-------------------------------------------------

-- https://supabase.com/blog/2020/11/18/postgresql-views
create view heatmap_days as
  select    date(created_at), created_by, count(*)
  from      practice_attempts
  where     created_at > current_date - interval '1 year'
  group by  date(created_at), created_by;

create view user_scores as
  select    created_by, count(distinct phrase)
  from      practice_attempts
  where     is_correct = true
  group by  created_by;

-- https://stackoverflow.com/questions/27253333/how-to-calculate-ratio-using-sql-query
-- https://stackoverflow.com/questions/28736227/cast-syntax-to-convert-a-sum-to-float
create view user_phrase_scores as
  select
    created_by,
    phrase,
    count(*),
    sum(case when is_correct = true then 1 else 0 end) as num_correct,
    sum(case when is_correct = true then 1 else 0 end)::float/count(*)::float as percent_correct
  from practice_attempts
  group by created_by, phrase;
